# 密码学

主要研究编制密码 和 破译密码

---
### 1.1 古典密码学

**核心原理**: 替换法，移位法  
**凯撒加密**  
频度分析法进行破译密码，在不知道密码规则的前提下，进行破译密码   
### 1.2 近代密码学
**核心原理** 替换法，移位法  
### 1.3 现代密码学
1. 散列函数  
MD5, SHA-1, SHA-256, SHA-512
2. 对称加密
DES加密和解密，AES加密和解密  
对称加密核心原理：流加密，快加密  
加密模式：ECB CBC    
填充模式：NpPadding和PKCS5padding
3. 非对称加密
RSA 和 ECC  

---

# 密码学的历史

## 1.1古典密码学
1. 替换法
单表替换：原文密文使用同一张表    
例如： abcde--->swtrp   
多表替换：有多张表，原文和密文进行对比  
表单1:abcde--->swtrp  表单2:abcde--->csdhd  表单3:abcde--->dtgff  
原文：bee  
密钥：312
密文：tpd

2. 移位法
按照字母，在字母表上移动  
凯撒加密：
例如：abcde  往后移动两位---> cdefg  
3. 破解方式  
频率分析法

## 1.2 近代密码学  
**恩尼格玛机**  核心使用的也是移位法和替换法  
被图灵破解

## 1.3 现代密码学
1. 散列函数、哈希函数  
常见加密方式：MD5, SHA-1, SHA-256, SHA-512  
2. 对称加密  
使用同一把密钥进行加密和解密  
3. 非对称加密  
有两把密钥，使用公钥加密，必须使用私钥解密，或者私钥加密公钥解密  
## 1.4 如何设置密码才安全  
1. 密码不要太常见  
2. 各个应用软件里面的密码不要设置一样
3. 在设置密码的时候，可以加一些特殊的标记，注册京东，jd，zfb


## 1.5 频率分析法破解凯撒加密  
目的：在不知道密钥的情况下，也想破解密文  
原理：根据字母和字母组合出现频率破解  
当我们拿到密文的时候，密文里面也会出现一个频率最高的j，可以假设密文里面的j就是敏文里面的e，由此得到key1，假设第二高的字母，就是明文里面的t，由此得到key2，以此类推...
尝试所有的key进行破解，其中一份就是破解的明文。  

## 1.6 现代密码学
对称加密：  
加密和解密都是用同一把钥匙
- 例如：
    - 原文：3；  密钥：108
    - 加密：密文=3 * 108 = 324
    - 解密： 324/108=3
- 常见加密算法
    - DES 数据加密标准
    - AES 高级加密标准
- 特点
  - 加密速度快
  - 密文不可逆，密钥不能泄露
  - 如果在编码表找不到对应的字符会出现乱码
  - 一般需要结合base64一起使用

## 1.7 加密模式/填充模式  
- ECB 每一块独立加密，使用同一个密钥
  - 优点：可并行加密，加密速度快
  - 缺点：保密性不强
- CBC 每一块明文先与前一块密文进行抑或后在进行加密
  - 与上面相反
- 填充模式：如果分块后长度不足则填充

## 1.8 消息摘要/数字摘要/Hash

就是利用哈希加密保证数据完整性。防止被篡改。

**数字摘要（Digital Digest）**，通常也称为**哈希值（Hash Value）** 或**指纹（Fingerprint）**，是通过一个**哈希函数**将任意长度的数据（如一封邮件、一个视频、一整本书）**“压缩”**成一个固定长度、且几乎唯一的字符串的过程。



## 1.9 非对称加密
必须要有一对公私密钥
用公钥加密就用私钥解密，或者相反
1. 常见算法
  - RSA
  - ECC

## 1.10 数字签名
数字签名：公钥数字签名，只有信息的发送者，才能产生别人无法伪造的一段数字串  
先用hash函数生成数字摘要后，放在明文上面，完成数字签名，然后使用私钥进行加密就可以发送出去了  

## 1.11 数字证书
数字世界的“护照”或“营业执照”   
在没有数字证书之前，我们使用非对称加密（如数字签名）时，会遇到一个根本性问题：如何确信你拿到的公钥，真的属于你以为是的那个人？(中间人攻击)  
**核心作用**：将公钥与其所有者的身份信息进行强绑定，并由一个可信的第三方来担保这种绑定关系。
### 1.11.1 数字证书里有什么
1. 证书持有者的信息：
  - 通用名称（通常是网站域名，如 www.example.com）
  - 组织名称、所在地等。
2. 证书持有者的公钥：
  - 这是证书最核心的数据，就是要被证明所有权的那个公钥。
3. 证书颁发机构的信息：颁发此证书的CA机构的名称。
4. 数字签名：
  - 这是证书的灵魂！ 这个签名是由证书颁发机构的私钥对证书所有上述信息（持有者信息、公钥等）的哈希值进行加密而生成的。
5. 有效期

### 1.11.2 工作流程  
![证书工作流程](C:\Users\aurora\Downloads\dont_delete1.png)
工作流程如下：

1. 客户端请求：您的浏览器向服务器发起连接，表示想要建立一个安全通道。
2. 服务器出示证书：服务器收到请求后，将它的数字证书（以及一个必要的证书链，通常还包括中间CA的证书）发送给您的浏览器。这一步完全符合您的描述：“由网站所有者将证书发给客户端”。
3. 您的浏览器会做一系列严格的检查：
4. 建立安全连接：验证通过后，浏览器就知道它正在与真实的 www.example.com 通信。它会使用证书中的公钥来加密一个随机的“会话密钥”， 
并将其发送给服务器。只有持有对应私钥的服务器才能解密获得这个会话密钥。此后，双方就使用这个高效的会话密钥来加密所有通信内容。
- 使用临时密钥的原因：
  - 其一：性能：非对称加密太慢了，使用非对称加密建立对话后，切换到对称密钥加密速度更快
  - 其二：前向保密：每次会话使用临时密钥，用后即弃保障了安全性，好比你每次通信都使用一个一次性的、自毁的密码本（会话密钥）。即使对方后来知道了你传递密码本的方式（非对称加密），他也无法获得那些已经自毁的密码本的内容。
  - 限制密钥使用量：密码学中有一个原则：限制单个密钥的使用量和生命周期，以最小化密钥泄露造成的损失。  
----
## Feistel 网络结构：对称密钥
Feistel 网络的核心思想非常巧妙：用数据的另一半来加密当前这一半。    
**一个形象的比喻：编织麻花辫**：
- 你有两股头发（左半部分 L 和右半部分 R）。
- 在编织的每一股中，你并不直接处理两股头发，而是将其中一股固定，用另一股去缠绕它。
- 经过多次左右交替的缠绕后，两股头发就紧密地、复杂地交织在一起，难以分辨最初的形态

### 工作流程
1. 输入：将第 i-1 轮输出的数据块分为左右两等份，记为 L₍ᵢ₋₁₎ 和 R₍ᵢ₋₁₎。
2. 处理右半部分：
   - 将右半部分 R₍ᵢ₋₁₎ 和本轮的子密钥 Kᵢ 一起输入到一个函数 F（称为轮函数）中。
   - 轮函数 F 可以是一个相对简单的函数，但它必须是非线性的，这是提供“混乱”的关键。
3. 异或操作：将轮函数 F 的输出与左半部分 L₍ᵢ₋₁₎ 进行 XOR 操作。
4. 交换与输出：
   - 新的右半部分 Rᵢ 就是上一步 XOR 操作的结果。
   - 新的左半部分 Lᵢ 则直接等于旧的右半部分 R₍ᵢ₋₁₎。
   - 至此，第 i 轮的输出就是 (Lᵢ, Rᵢ)。  
   这个过程会重复进行 n 轮（例如在DES中是16轮），每一轮都使用一个不同的子密钥 Kᵢ。

### Feistel 网络的巨大优势  
这种看似简单的结构，带来了几个革命性的优点：  
1. 加密与解密的结构完全相同！  
这是 Feistel 网络最天才的设计。解密过程就是加密过程的镜像。  
- 加密时：输入是 (L₍ᵢ₋₁₎, R₍ᵢ₋₁₎)，使用密钥 Kᵢ，输出是 (Lᵢ, Rᵢ)。
- 解密时：输入是 (Lᵢ, Rᵢ)，使用相同的密钥 Kᵢ，输出是 (L₍ᵢ₋₁₎, R₍ᵢ₋₁₎)。  
唯一的区别是：子密钥的使用顺序是相反的。加密时用 K₁, K₂, ..., Kₙ，解密时就用 Kₙ, Kₙ₋₁, ..., K₁。  
带来的好处：在硬件实现上，你只需要设计一套电路。在软件实现上，你只需要写一个函数。这极大地节省了成本和复杂度。  
2. 轮函数 F 无需可逆！  
在非 Feistel 的结构中，解密通常需要加密步骤的逆操作，这就要求每一个组件（包括轮函数）都必须是可逆的，这大大增加了设计的难度和限制。  
而在 Feistel 网络中，轮函数 F 可以是任意复杂的、不可逆的函数。无论 F 是什么，由于其输出只是用于 XOR，整个结构天然就是可逆的。这给了密码设计者极大的自由度去设计一个非常强大、非线性的轮函数。  
---
## DES 加密算法
DES使用56位的密钥和64位的明文块进行加密。DES算法的分组大小是64位，因此，如果需要加密的明文长度不足64位，
需要进行填充；如果明文长度超过64位，则需要使用分组模式进行分组加密。  
### 加密流程
![](https://i-blog.csdnimg.cn/blog_migrate/13057fca8d2ae93a87bbceb559746832.png)  

1. 初始置换（IP置换）：将输入的64位明文块进行置换和重新排列，生成新的64位数据块。
2. 加密轮次：DES加密算法共有16个轮次，每个轮次都包括四个步骤：
- 将64位数据块分为左右两个32位块。
- 右侧32位块作为输入，经过扩展、异或、置换等操作生成一个48位的数据块。这个48位的数据块被称为“轮密钥”，它是根据加密算法的主密钥生成的子密钥。
- 将左侧32位块和轮密钥进行异或运算，结果作为新的右侧32位块。
- 将右侧32位块与原来的左侧32位块进行连接，生成一个新的64位数据块，作为下一轮的输入。
3. 末置换（FP置换）：在最后一个轮次完成后，将经过加密的数据块进行置换和重新排列，得到加密后的64位密文。  
**注**: 1,3这两步在现代密码学看来不增加任何安全性，它们的作用可能只是为了适应当年硬件的数据加载方式。

#### 加密轮次:具体介绍
1. 初始置换完成后，明文被划分成了相同长度（32位）的左右两部分，记作L0,R0。接下来就会进行16个轮次的加密了。  
右半部分R0会作为下一轮次的左半部分L1的输入。其次，R0会补位到48位和本轮次生成的48位K0(马上讲K0的生成)输入到F轮函数中去。F函数的输出结果为32位，
结果 F(R0,K0)会和L0进行异或运算作为下一轮次右半部分R1的输入。以此类推，重复16轮运算。    
2. F轮函数  
   1. 拓展R到48位，按官方扩张规则
   2. 子密钥K的生成：DES算法采用了每轮子密钥生成的方式来增加密钥的复杂性和安全性。每轮子密钥都是由主密钥（64位）
   通过密钥调度算法（Key Schedule Algorithm）生成的。DES算法的密钥调度算法可以将64位的主密钥分成16个子密钥，每个子密钥48位，
   用于每轮加密中与输入数据进行异或运算。
   3. 当前轮次的子密钥与拓展的48位R进行异或运算
   4. S盒替换（Substitution Box substitution）：DES中S盒替换用于将上一轮异或运算的48位结果映射到32位输出中去。
   5. P盒替换
3. 该结果F(R0,K0)与L0进行异或运算得到下一轮的右半部分R1
                 

原文链接：https://blog.csdn.net/Demonslzh/article/details/129129493   



---

## SPN结构  
SPN的全称是 Substitution-Permutation Network，即 替换-置换网络。  
它的核心思想非常直接：在每一轮中，对整个数据块进行一系列并行的、局部的混淆操作，然后再进行一个整体的扩散操作，如此重复多轮。  
### 加密步骤
1. 轮密钥加：
    - 输入数据与本轮的子密钥 Kᵢ 进行异或操作。这是将密钥引入流程的第一步。
2. S盒替换层
   - 这是提供混淆 的关键步骤，是非线性的。
   - 将数据分成多个小分组（例如，8位或4位一组），每个分组独立地通过一个S盒进行查表替换。  
   - S盒是一个固定的替换表，输入一个值，输出一个完全不同的、看似不相关的值。它的设计目标是破坏输入和输出之间任何线性的数学关系。  
   - 因为S盒是并行应用的，所以能高效地实现整个数据块的混淆。  
3. P盒置换层：  
   - 这是提供扩散 的关键步骤，是线性的。
   - 对S盒替换后的整个数据块进行一个比特位的重新排列。
   - 它的设计目标是让一个输入比特的变化，在经过一轮后能影响到尽可能多的输出比特，从而将S盒的局部混淆效果迅速扩散到整个数据块。
4. （可选）轮密钥加  
为下一轮准备，可能会再次与一个子密钥进行异或。在有些设计中，这一步可能被视为下一轮的开始。  

这个过程会重复进行 N 轮。通常，最后一轮会省略P盒置换层，以避免其操作被轻易逆转，从而简化整体设计。  
### SPN结构的特点和优势
1. 高速扩散：由于每一轮都对整个数据块进行置换，SPN结构通常能比Feistel网络在更少的轮数内实现充分的混淆和扩散。  
2. 并行性：S盒替换是天然并行的，多个S盒可以同时计算，这在硬件实现上非常高效。 
3. 设计直观：结构清晰，混淆层和扩散层分离，便于分析和设计。  
4. 加解密结构可能不同： 与Feistel网络不同，SPN的加密和解密过程通常需要使用不同的电路或代码（需要逆S盒和逆P盒）。  

---

## Feistel对比SPN

### 1. 性能与效率：SPN的扩散速度更快

- Feistel结构：每一轮只加密/处理一半的数据块。这意味着要将整个数据块完全“搅拌”均匀，需要更多的轮数。它的扩散速度相对较慢。  
- SPN结构：每一轮都对整个数据块进行全面的非线性替换和线性置换。这意味着它能在更少的轮数内实现充分的混淆和扩散。  

为了达到同等级别的安全性，SPN结构通常可以比Feistel结构使用更少的轮数，从而获得更高的吞吐量和更低的延迟。这在当今高速网络和大数据环境下是一个关键优势。  

### 2. 对侧信道攻击的抵抗力
侧信道攻击是通过测量算法的执行时间、功耗、电磁辐射等物理信息来破解密钥，是现代密码实现的主要威胁。  
- Feistel结构：加解密过程虽然相似，但并不完全相同（子密钥顺序相反）。攻击者可以分别分析加密和解密过程，这可能会为侧信道攻击提供更多的攻击面。  
- SPN结构：加解密过程通常是完全不同的操作（需要使用逆S盒和逆置换）。虽然这增加了实现复杂度，但也意味着加密和解密路径可以分别进行针对性的加固，有时反而更容易防护。    

更重要的是，SPN结构（尤其是AES）的每一步操作都高度规整，适合用掩码等技术来防御侧信道攻击，这些防护技术在硬件和软件上都更容易实现。   

### 3. 设计与分析的简易性  
- Feistel结构：其安全性严重依赖于轮函数 F 的设计。虽然 F 本身不需要可逆，但设计一个既安全、高效又能与整个结构良好协同的 F 函数并非易事。  
- SPN结构：结构上更模块化和直观。设计者可以独立地优化两个核心部件：  
  - S盒：专注于提供最强的非线性混淆。  
  - 扩散层：专注于提供最快的扩散速度。
  这种清晰的分工使得密码分析家可以更轻松、更彻底地分析算法的安全性。

### 4. 并行化潜力  
- SPN结构：其S盒替换层是天然并行的。所有S盒可以同时进行计算，这在现代多核处理器和专用硬件上可以带来巨大的性能提升。  
- Feistel结构：由于每一轮的输出依赖于上一轮的全部结果，其固有的串行特性限制了并行化的能力。  












---

## AES分组加密算法  
高级加密标准(AES,Advanced Encryption Standard)为最常见的对称加密算法(微信小程序加密传输就是用这个加密算法的)。对称加密算法也就是加密和解密用相同的密钥，具体的加密流程如下图：  
原文链接：https://blog.csdn.net/qq_28205153/article/details/55798628  
### AES基本结构  
AES的处理单位是字节，128位的输入明文分组P和输入密钥K都被分成16个字节，分别记为P = P0 P1 … P15 和 K = K0 K1 … K15。如，明文分组为P = abcdefghijklmnop,其中的字符a对应P0，p对应P15。一般地，明文分组用字节为单位的正方形矩阵描述，称为状态矩阵。在算法的每一轮中，状态矩阵的内容不断发生变化，最后的结果作为密文输出。该矩阵中字节的排列顺序为从上到下、从左至右依次排列  

### 密钥扩展  
128位密钥也是用字节为单位的矩阵表示，矩阵的每一列被称为1个32位比特字。通过密钥编排函数该密钥矩阵被扩展成一个44个字组成的序列W[0],W[1], … ,W[43],该序列的前4个元素W[0],W[1],W[2],W[3]是原始密钥，用于加密运算中的初始密钥加（下面介绍）;后面40个字分为10组，每组4个字（128比特）分别用于10轮加密运算中的轮密钥加  
### 加密过程  
加密的第1轮到第9轮的轮函数一样，包括4个操作：字节代换、行位移、列混合和轮密钥加。最后一轮迭代不执行列混合。另外，在第一轮迭代之前，先将明文和原始密钥进行一次异或加密操作。  
1. 字节代换：加密用S盒，解密用逆S盒
2. 行移位ShiftRows：行移位是一个简单的左循环移位操作。当密钥长度为128比特时，状态矩阵的第0行左移0字节，第1行左移1字节，第2行左移2字节，第3行左移3字节  
行移位的逆变换：行移位的逆变换是将状态矩阵中的每一行执行相反的移位操作，例如AES-128中，状态矩阵的第0行右移0字节，第1行右移1字节，第2行右移2字节，第3行右移3字节。  
3. 列混合MixColumns：列混合变换是通过矩阵相乘来实现的，经行移位后的状态矩阵与固定的矩阵相乘，得到混淆后的状态矩阵，如下图的公式所示：  
逆向列混合变换同样由矩阵乘法定义  
4. 轮密钥加：轮密钥加是将128位轮密钥Ki同状态矩阵中的数据进行逐位异或操作  
### 解密过程  
加密过程的逆操作  

---

## PRESENT轻量级对称加密算法

---

## ASCON轻量级标准加密算法
详解链接：https://lmzyoyo.top/archives/asconencryption#%E8%BF%87%E7%A8%8B  
官方链接：https://ascon.isec.tugraz.at/

Ascon 已被选为美国国家标准与技术研究院（NIST）轻量级加密竞赛（2019 - 2023 年）中新的轻量级**认证加密**和**哈希标准**。  
Ascon 还被选为 CAESAR 竞赛（2014 - 2019 年）最终方案集中轻量级认证加密的首选算法。  
ASCON是一个算法家族主要包括认证加密和哈希函数两部分：官方推荐是ASCON-128 + ASCON-HASH组合



## 哈希/数字摘要/指纹

**数字摘要（Digital Digest）**，通常也称为**哈希值（Hash Value）** 或**指纹（Fingerprint）**，是通过一个**哈希函数**将任意长度的数据（如一封邮件、一个视频、一整本书）**“压缩”**成一个固定长度、且几乎唯一的字符串的过程。

### 哈希函数的工作原理

哈希函数就像一个“数据搅拌机”，它接收输入，经过一系列复杂的数学运算，输出一个固定长度的结果。这个过程是**单向的**。

**一个简化的、概念性的过程如下：**

1. **接收输入**：输入可以是任何数据，长度任意。
2. **分块处理**：将输入数据分割成等大小的块。
3. **压缩计算**：通过一系列复杂的**位运算**（如与、或、非、异或）、**模运算**和**逻辑函数**，将当前数据块与上一个块的运算结果进行混合。这个过程会彻底打乱原始数据的结构。
4. **产生输出**：经过多轮混合后，最终生成一个固定长度的字符串（例如，SHA-256算法总是产生一个256位，即64个十六进制字符的字符串）。

### 一个优质密码学哈希函数必须拥有的四大特性

#### 1. **原像不可逆性**

- **定义**：从哈希值 **H** 出发，不可能（在计算上不可行）反向推导出原始输入数据 **M**。
- **比喻**：给你一份“汤的指纹”（味道签名），你不可能还原出汤里具体放了哪些食材和调料。
- **重要性**：这是保证哈希可用于存储密码（不存储明文，只存储哈希值）和承诺协议的基础。

#### 2. **弱抗碰撞性**

- **定义**：给定一个输入 **M1**，很难找到另一个不同的输入 **M2**，使得它们的哈希值相同（即 H(M1) = H(M2)）。
- **比喻**：你有一碗特定的汤 **M1**，你想另做一碗味道完全一样的汤 **M2**，但用料完全不同，这几乎是不可能的。
- **重要性**：防止攻击者伪造一个具有相同“指纹”的假数据来替代真数据。

#### 3. **强抗碰撞性**

- **定义**：很难找到任意两个不同的输入 **M1** 和 **M2**，使得它们的哈希值相同（H(M1) = H(M2)）。
- **区别**：弱抗碰撞是针对“已知一个”找另一个；强抗碰撞是“任意找两个”碰撞的。
- **重要性**：这是哈希函数安全性的最高标准。如果一个哈希函数的强抗碰撞性被破解（如MD5），就意味着攻击者可以精心构造两个不同的文件却拥有相同的哈希值，这在对文件签名等领域是灾难性的。

#### 4. **雪崩效应**

- **定义**：输入的微小改变（哪怕只改一个比特位），会导致输出的哈希值发生**巨大、不可预测**的改变。
- **例子**：
  - `"hello world"` -> 哈希值可能是 `fc3ff98e8c6a0d...`
  - `"hello worle"` （只改了最后一个字母）-> 哈希值会变成 `d6b69335beb706...`
  - 可以看到，两个哈希值看起来毫无关联。
- **重要性**：确保了哈希值的随机性和不可预测性，使得无法通过猜测来逼近原始输入。

### 实际应用场景

1. **密码存储**
   - 网站不存储你的明文密码，而是存储你密码的哈希值。
   - 当你登录时，网站将你输入的密码进行哈希运算，与存储的哈希值比对。相同则通过。
   - 即使数据库泄露，攻击者拿到的也只是哈希值，无法轻易反推出你的原始密码。
2. **数据完整性校验**
   - 从网上下载软件或文件时，官网通常会提供该文件的哈希值（如SHA-256）。
   - 你下载后，可以在本地计算文件的哈希值，与官网提供的对比。
   - 如果一致，说明文件在传输过程中完好无损，未被篡改。
3. **数字签名**
   - 对一份很长的文件直接进行非对称加密签名效率很低。
   - 实际做法是：先对文件生成一个简短的哈希值，然后对这个哈希值进行签名。
   - 因为哈希值代表了文件的唯一性，对它的签名就等效于对文件本身的签名。
4. **区块链与加密货币**
   - 区块链中的每一个区块都包含了前一个区块数据的哈希值，形成一条“链”。
   - 任何对历史区块数据的修改都会导致其哈希值剧变，从而被后续所有区块检测到，确保了区块链的不可篡改性。
